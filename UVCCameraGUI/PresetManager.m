//
//  PresetManager.m
//  UVCCameraGUI
//
//  Created by UVC Camera GUI Tool
//
// Copyright (2025) Thomas Gallaway (github:atomist23)
// Portions copyright (c) Dr. Jeffrey Frey, IT-NSS, 2016, licensed under the MIT License.
//

#import "PresetManager.h"

@implementation PresetManager

- (BOOL)savePreset:(NSDictionary *)preset toFile:(NSString *)filePath {
    if (!preset || !filePath) {
        return NO;
    }
    
    NSMutableString *yamlContent = [[NSMutableString alloc] init];
    
    // Add header comment
    [yamlContent appendString:@"# UVC Camera Control Preset\n"];
    [yamlContent appendString:@"# Generated by UVC Camera GUI\n"];
    
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateStyle:NSDateFormatterMediumStyle];
    [formatter setTimeStyle:NSDateFormatterMediumStyle];
    NSString *dateString = [formatter stringFromDate:[NSDate date]];
    [formatter release];
    
    [yamlContent appendFormat:@"# Created: %@\n\n", dateString];
    
    // Add controls section
    [yamlContent appendString:@"controls:\n"];
    
    // Sort keys for consistent output
    NSArray *sortedKeys = [[preset allKeys] sortedArrayUsingSelector:@selector(compare:)];
    
    for (NSString *key in sortedKeys) {
        NSNumber *value = [preset objectForKey:key];
        if ([value isKindOfClass:[NSNumber class]]) {
            // Format the control name to be more readable
            NSString *formattedKey = [self formatControlName:key];
            
            if ([value floatValue] == [value intValue]) {
                [yamlContent appendFormat:@"  %@: %d\n", formattedKey, [value intValue]];
            } else {
                [yamlContent appendFormat:@"  %@: %.2f\n", formattedKey, [value floatValue]];
            }
        }
    }
    
    // Write to file
    NSError *error = nil;
    BOOL success = [yamlContent writeToFile:filePath
                                 atomically:YES
                                   encoding:NSUTF8StringEncoding
                                      error:&error];
    
    [yamlContent release];
    
    if (!success) {
        NSLog(@"Error writing preset file: %@", [error localizedDescription]);
    }
    
    return success;
}

- (NSDictionary *)loadPresetFromFile:(NSString *)filePath {
    if (!filePath) {
        return nil;
    }
    
    NSError *error = nil;
    NSString *content = [NSString stringWithContentsOfFile:filePath
                                                   encoding:NSUTF8StringEncoding
                                                      error:&error];
    
    if (!content) {
        NSLog(@"Error reading preset file: %@", [error localizedDescription]);
        return nil;
    }
    
    return [self parseYAMLContent:content];
}

- (NSDictionary *)parseYAMLContent:(NSString *)content {
    NSMutableDictionary *result = [[NSMutableDictionary alloc] init];
    
    NSArray *lines = [content componentsSeparatedByString:@"\n"];
    BOOL inControlsSection = NO;
    
    for (NSString *line in lines) {
        NSString *trimmedLine = [line stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
        
        // Skip comments and empty lines
        if ([trimmedLine hasPrefix:@"#"] || [trimmedLine length] == 0) {
            continue;
        }
        
        // Check for controls section
        if ([trimmedLine isEqualToString:@"controls:"]) {
            inControlsSection = YES;
            continue;
        }
        
        // Parse control values
        if (inControlsSection && [trimmedLine hasPrefix:@"  "]) {
            NSRange colonRange = [trimmedLine rangeOfString:@":"];
            if (colonRange.location != NSNotFound) {
                NSString *key = [[trimmedLine substringToIndex:colonRange.location] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
                NSString *valueString = [[trimmedLine substringFromIndex:colonRange.location + 1] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
                
                // Convert formatted key back to original control name
                key = [self unformatControlName:key];
                
                // Parse value
                NSNumber *value = nil;
                if ([valueString containsString:@"."]) {
                    value = @([valueString doubleValue]);
                } else {
                    value = @([valueString integerValue]);
                }
                
                [result setObject:value forKey:key];
            }
        } else if (inControlsSection && ![trimmedLine hasPrefix:@"  "]) {
            // End of controls section
            inControlsSection = NO;
        }
    }
    
    return [result autorelease];
}

- (NSString *)formatControlName:(NSString *)controlName {
    // Convert camelCase or dash-separated names to more readable format
    // Example: "backlight-compensation" -> "backlight_compensation"
    // or "whiteBalanceTemp" -> "white_balance_temp"
    
    NSString *formatted = [controlName stringByReplacingOccurrencesOfString:@"-" withString:@"_"];
    
    // Handle camelCase by inserting underscores before capital letters
    NSMutableString *result = [[NSMutableString alloc] init];
    for (NSUInteger i = 0; i < [formatted length]; i++) {
        unichar c = [formatted characterAtIndex:i];
        if (i > 0 && [[NSCharacterSet uppercaseLetterCharacterSet] characterIsMember:c]) {
            [result appendString:@"_"];
        }
        [result appendFormat:@"%C", [[NSCharacterSet lowercaseLetterCharacterSet] characterIsMember:c] ? c : tolower(c)];
    }
    
    return [result autorelease];
}

- (NSString *)unformatControlName:(NSString *)formattedName {
    // Convert back from formatted name to original control name
    // This is a reverse mapping - we'll need to try different formats
    
    // Try dash-separated format first (most common in UVC)
    NSString *dashFormat = [formattedName stringByReplacingOccurrencesOfString:@"_" withString:@"-"];
    
    // Return the dash format as it's most commonly used in UVC control names
    return dashFormat;
}

@end